#!/usr/bin/env python3

import os
import sys
import glob
import shutil
from pathlib import Path
from setuptools import setup

# These paths will be configured by CMake
PROJECT_SOURCE_DIR = "@PROJECT_SOURCE_DIR@"
PROJECT_BINARY_DIR = "@PROJECT_BINARY_DIR@"

# Get the platform-specific library extension
if sys.platform == "darwin":
    lib_ext = ".dylib"
elif sys.platform == "win32":
    lib_ext = ".dll"
else:  # linux
    lib_ext = ".so"

def find_solver_libs():
    """Find all solver-specific libraries recursively in the build directory."""
    solver_libs = {}
    build_dir = Path(PROJECT_BINARY_DIR)

    # First verify the base library exists
    base_lib = f"libsmt-switch{lib_ext}"
    base_lib_path = build_dir / base_lib
    if not base_lib_path.exists():
        raise FileNotFoundError(f"Could not find base library: {base_lib} in {build_dir}")

    # Use recursive glob to find all solver libraries
    pattern = f"**/libsmt-switch-*{lib_ext}"
    for lib_path in build_dir.glob(pattern):
        # Extract solver name from library filename
        lib_name = lib_path.name
        solver = lib_name.replace(f"libsmt-switch-", "").replace(lib_ext, "")

        # Create the solver package directory if it doesn't exist
        solver_pkg_dir = Path("smt_switch") / solver
        solver_pkg_dir.mkdir(parents=True, exist_ok=True)

        # Create an __init__.py file for the solver package
        init_file = solver_pkg_dir / "__init__.py"
        if not init_file.exists():
            init_file.touch()

        solver_libs[solver] = str(lib_path)

    return solver_libs

def copy_libraries():
    """Copy libraries to their proper package locations."""
    pkg_dir = Path("smt_switch")
    pkg_dir.mkdir(exist_ok=True)

    # Copy base library
    base_lib = f"libsmt-switch{lib_ext}"
    base_src = Path(PROJECT_BINARY_DIR) / base_lib
    base_dst = pkg_dir / base_lib

    if base_src.exists():
        shutil.copy2(str(base_src), str(base_dst))
    else:
        raise FileNotFoundError(f"Base library not found: {base_src}")

    # Copy solver libraries
    solver_libs = find_solver_libs()
    for solver, lib_path in solver_libs.items():
        dst_dir = pkg_dir / solver
        dst_path = dst_dir / Path(lib_path).name
        shutil.copy2(lib_path, str(dst_path))

# Get Python extension suffix
ext_filename = 'smt_switch' + sysconfig.get_config_var('EXT_SUFFIX')

# Set up package structure
solver_libs = find_solver_libs()
packages = ['smt_switch'] + [f'smt_switch.{solver}' for solver in solver_libs.keys()]

# Handle Cython compilation if the extension hasn't been built yet
if not os.path.isfile(os.path.join('smt_switch', ext_filename)):
    import sys
    from setuptools.extension import Extension
    from Cython.Build import cythonize

    # Handle macOS-specific settings
    if sys.platform == 'darwin':
        import platform
        mac_ver = os.environ.get("MACOSX_DEPLOYMENT_TARGET")
        if mac_ver is None:
            version_str, _, _ = platform.mac_ver()
            major_minor = version_str.split(".")[:2]
            mac_ver = ".".join(major_minor)
            os.environ.setdefault("MACOSX_DEPLOYMENT_TARGET", mac_ver)
        arch = "@MACOS_ARCH@"  # Set by CMake
        if not arch:
            arch = platform.machine()
        host_platform = "macosx-" + mac_ver + "-" + arch
        os.environ.setdefault("_PYTHON_HOST_PLATFORM", host_platform)
        arch_flags = "-arch " + arch
        os.environ.setdefault("ARCHFLAGS", arch_flags)

    # Cython compilation settings
    compiler_directives = {
        'language_level': 3,
        'binding': False,
    }

    extra_compile_args = ["-std=c++17"]
    if sys.platform == "win32":
        extra_compile_args += ["-DMS_WIN64"]
        os.environ['PATH'] += r';C:\msys64\mingw64\bin'

    # Set up the extension module
    ext_options = {
        "libraries": ["smt-switch"] + [f"smt-switch-{solver}" for solver in solver_libs.keys()],
        "library_dirs": ["@CMAKE_BINARY_DIR@"],
        "include_dirs": ["@PROJECT_SOURCE_DIR@/include"],
        "language": "c++",
        "extra_compile_args": extra_compile_args
    }

    ext_module = Extension(
        "smt_switch.smt_switch",
        ["smt_switch.pyx"],
        **ext_options
    )
    ext_module.cython_directives = {"embedsignature": True}

    # Copy libraries and set up the package
    copy_libraries()

    setup(
        ext_modules=cythonize([ext_module], compiler_directives=compiler_directives),
        packages=packages,
        package_data={'': [f'*{lib_ext}']},
    )
else:
    # If extension is already built, just include it in the package
    copy_libraries()

    setup(
        packages=packages,
        package_data={'': [f'*{lib_ext}']},
        has_ext_modules=lambda: True,
    )
